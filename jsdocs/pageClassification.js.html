<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: pageClassification.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: pageClassification.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Classify web pages based on their content, title, and URL
 * Inject content scripts to  scripts   using an arbitrary classifier in reponse to messages from content scripts
 * @module webScience.pageClassification
 */
import * as messaging from "./messaging.js";
import * as debugging from "./debugging.js";
import * as matching from "./matching.js";
import * as events from "./events.js";
import Readability from "@mozilla/readability";
import * as contentScripts from "./contentScripts.js"
import pageContentContentScript from "./content-scripts/pageContent.content.js"

const debugLog = debugging.getDebuggingLog("pageClassification");


class ClassificationEvent extends events.Event {
    constructor(args) {
        super(args);
        this.workers = {};
        this.registeredCS = null;
        this.existingMatchPatterns = null;
    }

    async addListener(listener, options) {
        super.addListener(listener, options);
        if (options.workerId in this.workers) {
            debugLog(`Adding listener for same worker ${options.workerId}`);
            return;
        }

        if (this.registeredCS == null) this.listenForContentScriptMessages();
        await this.registerContentScripts(options.matchPatterns);

        const newWorker = {
            workerId: options.workerId,
            filePath: options.filePath,
            matchPatterns: options.matchPatterns,
            matcher: new matching.MatchPatternSet([]),
            workerObj: new Worker(options.filePath),
            initialArgs: options.initArgs
        };
        newWorker.matcher.import(options.exportedMatcher);
        this.workers[options.workerId] = newWorker;
        newWorker.workerObj.onmessage = this.resultReceiver.bind(this);
        newWorker.workerObj.onerror = (e) => {console.log(e);};

        newWorker.workerObj.postMessage({
            type: "init",
            name: options.workerId,
            args: options.initArgs
        });
    }

    notifyListeners(listenerArguments) {
        super.notifyListeners(listenerArguments);
    }

    removeListener(listener) {
        //unregisterClassifier(listener);
        super.removeListener(listener);
    }

    resultReceiver(result) {
        const data = result.data;
        data.url = matching.normalizeUrl(data.url);
        const classificationResult = {...data};//, ...pageContent.context};
        this.notifyListeners([classificationResult]);
    }
    /**
     * Listen for messages from content script, pass them to classifier, listens for
     * classification results and sends back results to the registered result
     * listener function
     *
     */
     listenForContentScriptMessages() {
        messaging.registerListener("webScience.pageClassification.pageContent", (pageContent, sender) => {
            if (!("tab" in sender)) {
                debugLog("Warning: unexpected message");
                return;
            }
            // add tab id to metadata
            pageContent.context["tabID"] = sender.tab.id;

            // fetch worker associated with this
            for (const workerName in this.workers) {
                const worker = this.workers[workerName]
                if (worker.matcher.matches(pageContent.url)) {
                    worker.workerObj.postMessage({
                        type: "classify",
                        payload: pageContent,
                    });
                }
            }
        });
     }

    /**
     * Registers readability script for pages that belong to a set of patterns.
     *
     * Injects readability content scripts that match given patterns. The content
     * script extracts page metadata and sends it back.
     * @param {Array.string} matchPatterns - Match patterns of the form scheme://&lt;host>&lt;path>
     * @param {string} workerId - an identifier for the background script and content
     * script to communicate
     */
    async registerContentScripts(newMatchPatterns) {
        if (this.existingMatchPatterns == null) this.existingMatchPatterns = new Set();
        const numExistingMatchPatterns = this.existingMatchPatterns.size;

        newMatchPatterns.forEach((matchPattern) => {
            this.existingMatchPatterns.add(matchPattern);
        });

        const numTotalMatchPatterns = this.existingMatchPatterns.size;
        if (numExistingMatchPatterns == numTotalMatchPatterns) return;

        // otherwise, we need to get rid of the old ones and re-register with the new
        // set of match patterns
        if (this.registeredCS) this.registeredCS.unregister();

        this.registeredCS = await browser.contentScripts.register({
            matches: [...this.existingMatchPatterns],
            js: [{
                code: contentScripts.unpack(pageContentContentScript)
            }],
            runAt: "document_idle"
        });
    }

    fetchClassificationResult(url, workerId) {
        fetch(url).then((response) => {
            response.text().then((resp) => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(resp, 'text/html');
                const pageContent = new Readability.Readability(doc).parse();
                const toSend = {
                    url : url,
                    title: pageContent.title,
                    text : pageContent.textContent,
                    pageId: null,
                    context : {
                        timestamp : Date.now(),
                        referrer : ""
                    }
                }
                this.messageWorker(workerId, toSend);
            });
        });
    }

    messageWorker(workerId, pageContent) {
        const worker = this.workers[workerId];
        worker.workerObj.postMessage({
            type: "classify",
            payload: pageContent,
        });
    }

}

export const onClassificationResult = new ClassificationEvent(
    {notifyListenersCallback: filterResults});

function filterResults(listener, results, options) {
    return results[0].type == options.workerId;
}

export function fetchClassificationResult(url, workerId) {
    onClassificationResult.fetchClassificationResult(url, workerId);
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="webScience.module_contentScripts.html">contentScripts</a></li><li><a href="webScience.module_dataAnalysis.html">dataAnalysis</a></li><li><a href="webScience.module_debugging.html">debugging</a></li><li><a href="webScience.module_events.html">events</a></li><li><a href="webScience.module_idle.html">idle</a></li><li><a href="webScience.module_linkExposure.html">linkExposure</a></li><li><a href="webScience.module_linkResolution.html">linkResolution</a></li><li><a href="webScience.module_matching.html">matching</a></li><li><a href="webScience.module_messaging.html">messaging</a></li><li><a href="webScience.module_pageClassification.html">pageClassification</a></li><li><a href="webScience.module_pageManager.html">pageManager</a></li><li><a href="webScience.module_pageNavigation.html">pageNavigation</a></li><li><a href="webScience.module_scheduling.html">scheduling</a></li><li><a href="webScience.module_socialMediaActivity.html">socialMediaActivity</a></li><li><a href="webScience.module_socialMediaLinkSharing.html">socialMediaLinkSharing</a></li><li><a href="webScience.module_storage.html">storage</a></li><li><a href="webScience.module_userSurvey.html">userSurvey</a></li></ul><h3>Classes</h3><ul><li><a href="webScience.module_events.Event.html">Event</a></li><li><a href="webScience.module_events.EventSingleton.html">EventSingleton</a></li><li><a href="webScience.module_events.EventWithoutOptions.html">EventWithoutOptions</a></li><li><a href="webScience.module_matching.MatchPatternSet.html">MatchPatternSet</a></li><li><a href="webScience.module_storage.Counter.html">Counter</a></li><li><a href="webScience.module_storage.IndexedStorage.html">IndexedStorage</a></li><li><a href="webScience.module_storage.KeyValueStorage.html">KeyValueStorage</a></li></ul><h3>Interfaces</h3><ul><li><a href="webScience.module_linkExposure-LinkExposureDetails.html">LinkExposureDetails</a></li><li><a href="webScience.module_pageNavigation-PageDataDetails.html">PageDataDetails</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Tue Apr 06 2021 12:42:55 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
