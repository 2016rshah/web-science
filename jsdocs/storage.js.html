<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: storage.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: storage.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * This module provides convenient storage abstractions. Implementing storage in
 * a utility module, rather than directly calling browser storage APIs, avoids code
 * duplication and allows us to swap out the underlying storage implementation if
 * needed (e.g., switching from localforage to Dexie, or directly using browser
 * storage APIs).
 *
 * @module webScience.storage
 */

import Dexie from 'dexie';

export const storageInstances = [];

export class IndexedStorage {
    /**
     * Create a storage area with indexed fields.
     * Storage is implemented with Dexie. The `stores` field specifies the Dexie tables to be created
     * and their indexed fields. See the Dexie documentation for syntax: https://dexie.org/docs/Version/Version.stores().
     * @param {string} storageAreaName - A name that uniquely identifies the storage area.
     * @param {Object} stores - The tables to be created, see Dexie documentation linked above.
     * @param {string} defaultStore - The table to use if one is not specified in future interactions.
     */
    constructor(storageAreaName, stores, defaultStore="") {
        this.storageAreaName = storageAreaName;
        this.defaultStore = defaultStore == "" ? Object.keys(stores)[0] : defaultStore;

        this.storageInstance = new Dexie(this.storageAreaName);
        this.storageInstance.version(1).stores(stores);
    }

    async set(item, store="") {
        await this.storageInstance[store === "" ? this.defaultStore : store].put(item);
    }

    async get(key, store="") {
        const result = await this.storageInstance[store == "" ? this.defaultStore : store].get(key);
        return result;
    }

    async getEventsByRange(startTime, endTime, timeKey, store=""){
        const result = await this.storageInstance[store=="" ? this.defaultStore : store].where(timeKey)
            .inAnyRange([[startTime, endTime]])
            .toArray();
        return result;
    }

}

/**
 * Class for a key-value storage area, where the key is a string and the value can have
 * any of a number of basic types.
 */
export class KeyValueStorage {
    /**
     * Create a key-value storage area. Only a name for the storage area is required.
     * Storage is implemented using the Dexie wrapper for IndexedDB. Clients that wish to
     * have multiple independent Dexie stores within this storage area can specify them with
     * the `storeNames` parameter. If none are specified, the module will create a default store
     * and use that store for future interactions.
     * @param {string} storageAreaName - A name that uniquely identifies the storage area.
     * @param {Array&lt;string>} storeNames - A list of names of stores.
     * @param {string} defaultStore - If store names are given, which one should be the default in future interactions.
     * @example var exampleStorage = await (new KeyValueStorage("exampleName"));
     */
    constructor(storageAreaName, storeNames=["default"], defaultStore = "") {
        this.storageAreaName = storageAreaName;
        const stores = {};
        for (const storeName in storeNames) stores[storeNames[storeName]] = "key";

        this.defaultStore = defaultStore === "" ? Object.keys(stores)[0] : defaultStore;

        this.storageInstance = new Dexie(this.storageAreaName);
        this.storageInstance.version(1).stores(stores);
        return this;
    }

    /**
     * Get a value from storage.
     * @param {string} key - The key to use in the storage area.
     * @param {string} store - The name of the store from which to access the key
     * @returns {Promise&lt;Array>|Promise&lt;ArrayBuffer>|Promise&lt;Blob>|Promise&lt;Float32Array>|Promise&lt;Float64Array>|
     * Promise&lt;Int8Array>|Promise&lt;Int16Array>|Promise&lt;Int32Array>|Promise&lt;Number>|Promise&lt;Object>|Promise&lt;Uint8Array>|
     * Promise&lt;Uint8ClampedArray>|Promise&lt;Uint16Array>|Promise&lt;Uint32Array>|Promise&lt;string>} The value in the
     * storage area for the key, or `null` if the key is not in storage.
     */
    async get(key, store="") {
        const result = await this.storageInstance[store == "" ? this.defaultStore : store].get(key);
        if (result) return result.value;
        return null;
    }

    /**
     * Set a value in storage.
     * @param {string} key - The key to use in the storage area.
     * @param {(Array|ArrayBuffer|Blob|Float32Array|Float64Array|Int8Array|Int16Array|Int32Array|
     * Number|Object|Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|string)} value - The value
     * to store in the storage area for the key.
     * @param {string} store - The name of the store where the pair should be placed
     */
    async set(key, value, store="") {
        await this.storageInstance[store == "" ? this.defaultStore : store].put({key: key, value: value});
    }

    /**
     * Create an object where with a property-value pair for each key-value pair in the storage area.
     * Note that this could be slow and consume excessive memory if the storage area contains a lot
     * of data.
     * @param {string} The store whose contents to return
     * @returns {Promise&lt;Object>} An object that reflects the content in the storage area.
     */
    async getContentsAsObject(store="") {
        const storeToAccess = this.storageInstance[store == "" ? this.defaultStore : store];
        const output = { };
        storeToAccess.each(async (object) => {
            output[object.key] = object.value;
        });

        return output;
    }
}

/** Class for maintaining persistent counters (e.g., unique IDs). */
export class Counter {
    /**
     * Create a persistent counter. Note that, because creating a counter
     * requires asynchronous calls (which cannot happen in a constructor),
     * the counter will not be setup until a subsequent call to `initialize()`.
     * @param {string} counterName - A name that uniquely identifies the counter.
     * @example var exampleCounter = await (new Counter("exampleName")).initialize();
     */
    constructor(counterName) {
        this.counterName = counterName;
        this.counterValue = 0;
    }

    /**
     * Complete creation of the persistent counter. Returns itself for convenience.
     * @returns {Object} The persistent counter.
     */
    async initialize() {
        if(Counter.storage == null)
            Counter.storage = new KeyValueStorage("webScience.storage.counter");
        const initialCounterValue = await Counter.storage.get(this.counterName);
        if(initialCounterValue != null)
            this.counterValue = initialCounterValue;
        else
            await Counter.storage.set(this.counterName, this.counterValue);
        return this;
    }

    /**
     * Get the current value of the counter. The value is cached in memory, which allows
     * this function to be synchronous.
     * @returns {number} The current value of the counter.
     */
    get() {
        return this.counterValue;
    }

    /**
     * Increment the value of the counter by a number and return the incremented value.
     * The cached counter value is synchronously incremented; the stored
     * counter value is asynchronously incremented.
     * @param {number} incrementValue - The amount to increment the counter.
     * @returns {Promise&lt;number>} - The counter value after incrementing.
     */
    async incrementByAndGet(incrementValue) {
        const currentCounterValue = (this.counterValue = this.counterValue + incrementValue);
        await Counter.storage.set(this.counterName, this.counterValue);
        return currentCounterValue;
    }

    /**
     * Increment the value of the counter, ignoring the value. Identical to
     * the Promise returned by `counter.incrementByAndGet.then(value => return)`.
     * @param {number} incrementValue - The amount to increment the counter.
     */
    async incrementBy(incrementValue) {
        await this.incrementByAndGet(incrementValue);
        return;
    }

    /**
     * Increment the value of the counter and return the incremented value.
     * The cached counter value is synchronously incremented; the stored
     * counter value is asynchronously incremented.
     * @returns {Promise&lt;number>} - The counter value after incrementing.
     */
    async incrementAndGet() {
        // Saving the current counter value to avoid race conditions during
        // the asynchronous save to storage
        const currentCounterValue = (this.counterValue = this.counterValue + 1);
        await Counter.storage.set(this.counterName, this.counterValue);
        return currentCounterValue;
    }

    /**
     * Increment the value of the counter and return the value prior to
     * incrementing. Identical to the Promise returned by
     * `counter.incrementAndGet().then(value => return value - 1)`.
     * @returns {Promise&lt;number>} - The counter value before incrementing.
     */
    async getAndIncrement() {
        const ret = await this.incrementAndGet() - 1;
        return ret;
    }

    /**
     * Increment the value of the counter, ignoring the value. Identical to
     * the Promise returned by `counter.incrementAndGet.then(value => return)`.
     */
    async increment() {
        await this.incrementAndGet();
        return;
    }

    async getAndReset() {
        const currentCounterValue = this.counterValue;
        this.counterValue = 0;
        await Counter.storage.set(this.counterName, this.counterValue);
        return currentCounterValue;
    }

    /**
     * Create an object with a property-value pair for each counter name-value pair.
     * @returns {Promise&lt;Object>} An object that reflects the set of counters.
     */
    static async getContentsAsObject() {
        return await Counter.storage.getContentsAsObject();
    }
}

export async function getEventsByRange(startTime, endTime, instances) {
    const events = {};
    for (const instance of instances) {
        const storage = instance.storage;
        const store = instance.store;
        const timeKey = instance.timeKey;
        events[instance.storage.storageAreaName + "." + store] = await storage.getEventsByRange(startTime, endTime, timeKey, store);
    }
    return events;
}

// Workaround for static class variable
Counter.storage = null;

// Prevents IndexedDB data from getting deleted without user intervention
// Ignoring the promise resolution because we still want to use storage
// even if Firefox won't guarantee persistence
navigator.storage.persist();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="webScience.module_contentScripts.html">contentScripts</a></li><li><a href="webScience.module_dataAnalysis.html">dataAnalysis</a></li><li><a href="webScience.module_debugging.html">debugging</a></li><li><a href="webScience.module_events.html">events</a></li><li><a href="webScience.module_idle.html">idle</a></li><li><a href="webScience.module_linkExposure.html">linkExposure</a></li><li><a href="webScience.module_linkResolution.html">linkResolution</a></li><li><a href="webScience.module_matching.html">matching</a></li><li><a href="webScience.module_messaging.html">messaging</a></li><li><a href="webScience.module_pageClassification.html">pageClassification</a></li><li><a href="webScience.module_pageManager.html">pageManager</a></li><li><a href="webScience.module_pageNavigation.html">pageNavigation</a></li><li><a href="webScience.module_scheduling.html">scheduling</a></li><li><a href="webScience.module_socialMediaActivity.html">socialMediaActivity</a></li><li><a href="webScience.module_socialMediaLinkSharing.html">socialMediaLinkSharing</a></li><li><a href="webScience.module_storage.html">storage</a></li><li><a href="webScience.module_userSurvey.html">userSurvey</a></li></ul><h3>Classes</h3><ul><li><a href="webScience.module_events.Event.html">Event</a></li><li><a href="webScience.module_events.EventSingleton.html">EventSingleton</a></li><li><a href="webScience.module_events.EventWithoutOptions.html">EventWithoutOptions</a></li><li><a href="webScience.module_matching.MatchPatternSet.html">MatchPatternSet</a></li><li><a href="webScience.module_storage.Counter.html">Counter</a></li><li><a href="webScience.module_storage.IndexedStorage.html">IndexedStorage</a></li><li><a href="webScience.module_storage.KeyValueStorage.html">KeyValueStorage</a></li></ul><h3>Interfaces</h3><ul><li><a href="webScience.module_linkExposure-LinkExposureDetails.html">LinkExposureDetails</a></li><li><a href="webScience.module_pageNavigation-PageDataDetails.html">PageDataDetails</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Tue Apr 06 2021 12:42:55 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
