<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: dataAnalysis.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: dataAnalysis.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * This module periodically runs analysis scripts (in a separate thread) and
 * reports the results.
 * @module webScience.dataAnalysis
 */

import { getDebuggingLog } from "./debugging.js";
import * as storage from "./storage.js";
import * as scheduling from "./scheduling.js";

const debugLog = getDebuggingLog("dataAnalysis");
/**
 * A Map that stores result listeners. The keys are worker script paths and the values
 * are Sets of message listeners associated with the worker script.
 * @private
 * @const {Map&lt;string,Set&lt;function>>}
 */
const resultRouter = new Map();

let storageSpace;

/**
 * Whether the module has completed setup.
 * @private
 * @type {boolean}
 */
let initialized = false;

let studyDomains = null;

let storageInstances = null;

/**
 * The end of the time range that the last aggregation run considered.
 * @private
 */
let lastAnalysisRangeEndTime;

/**
 * Setup for the module. Runs only once.
 * @private
 */
async function initialize() {
    if(initialized)
        return;
    initialized = true;
    debugLog("registering idle state listener for data analysis");
    storageSpace = new storage.KeyValueStorage();
    lastAnalysisRangeEndTime = await storageSpace.get("lastAnalysisRangeEndTime");
    if (lastAnalysisRangeEndTime == null) {
        lastAnalysisRangeEndTime = roundTimeUp(Date.now());
        await storageSpace.set("lastAnalysisRangeEndTime", lastAnalysisRangeEndTime);
    }
    console.log(lastAnalysisRangeEndTime);
    //Idle.registerIdleStateListener(idleStateListener, 1); // for testing
    scheduling.onIdleDaily.addListener(idleStateListener);
}

/**
 * A listener for idle state events from the Idle module
 * Triggers all analysis scripts that are registered to run
 * during idle state
 * @param {string} newState - The new browser idle state.
 * @private
 */
async function idleStateListener() {
    const currentTime = Date.now();
    const analysisStartTime = lastAnalysisRangeEndTime;
    const analysisEndTime = roundTimeDown(currentTime)
    if (lastAnalysisRangeEndTime &lt; analysisEndTime) {
        lastAnalysisRangeEndTime = analysisEndTime;
        await storageSpace.set("lastAnalysisRangeEndTime", lastAnalysisRangeEndTime);
        await triggerAnalysisScripts(analysisStartTime, analysisEndTime);
    }
}

/**
 * Handler for errors from worker threads
 * @param {Event} err - error
 */
function workerError(err) {
    debugLog("error :"+ err);
}

/**
 * Creates a receiver function for handling results from
 * worker script. The receiver function extracts the data part of the
 * result and sends it to all the listeners waiting for it.
 * @param {Set&lt;function>} listeners - listeners waiting for the results from
 * worker script
 * @returns {function} receiver function
 */
function createMessageReceiver(listeners) {
    function messageReceiver(result) {
        const data = result.data;
        debugLog("received message from worker script {"+ JSON.stringify(data) + "}. Now passing it to listeners");
        for(const listener of listeners) {
            listener(data.data);
        }
    }
    return messageReceiver;
}

/**
 * Trigger each analysis script in a separate worker thread
 * The result of analysis is passed on from the worker to the
 * registered listener function
 * @private
 */
export async function triggerAnalysisScripts(startTime, endTime) {
    const storageObjs = await storage.getEventsByRange(startTime, endTime, storageInstances);
    const toSend = {
        studyDomains: studyDomains,
        fromStorage: storageObjs,
    };

    for(const [scriptPath, listeners] of resultRouter) {
        const worker = new Worker(scriptPath);
        worker.postMessage(toSend);
        worker.addEventListener('message', createMessageReceiver(listeners));
        worker.addEventListener('error', workerError);
    }
}

/**
 * Register an analysis script and a listener for the results.
 * The script runs in a worker thread every day
 * @param {string} workerScriptPath - location of the worker script
 * @param {function} listener - The listener function.
 */
async function registerAnalysisResultListener(workerScriptPath, listener) {
    await initialize();
    let resultListeners = resultRouter.get(workerScriptPath);
    if (resultListeners === undefined) {
        resultListeners = new Set();
        resultRouter.set(workerScriptPath, resultListeners);
    }
    resultListeners.add(listener);
}

function roundTimeUp(timeStamp) {
    const timeStampObj = new Date(timeStamp);
    const endHour = Math.ceil(timeStampObj.getUTCHours() / 4) * 4;
    return Date.UTC(timeStampObj.getUTCFullYear(), timeStampObj.getUTCMonth(),
                    timeStampObj.getUTCDay(), endHour) - 1;
}

function roundTimeDown(timeStamp) {
    const timeStampObj = new Date(timeStamp);
    const endHour = Math.floor(timeStampObj.getUTCHours() / 4) * 4;
    return Date.UTC(timeStampObj.getUTCFullYear(), timeStampObj.getUTCMonth(),
                    timeStampObj.getUTCDay(), endHour);
}

/**
 * Registers analysis scripts and associated listener functions.
 * For each analysis name (identified by object keys), the function expects a
 * script and listener for the result. The analysis script is scheduled to
 * execute in a worker thread during browser idle time. The results from
 * analysis script are forwarded to the listener function.
 *
 * @param {Object} scripts
 * @param {Object.any.path} path - path for analysis script
 * @param {Object.any.resultListener} path - Listener function for processing
 * the result from analysis script
 */
export async function runStudy(scripts, studyDomainsParam, storageInstancesParam) {
    studyDomains = studyDomainsParam;
    storageInstances = storageInstancesParam;
    for (const [, scriptParameters] of Object.entries(scripts)) {
        await registerAnalysisResultListener(scriptParameters.path, scriptParameters.resultListener);
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="webScience.module_contentScripts.html">contentScripts</a></li><li><a href="webScience.module_dataAnalysis.html">dataAnalysis</a></li><li><a href="webScience.module_debugging.html">debugging</a></li><li><a href="webScience.module_events.html">events</a></li><li><a href="webScience.module_idle.html">idle</a></li><li><a href="webScience.module_linkExposure.html">linkExposure</a></li><li><a href="webScience.module_linkResolution.html">linkResolution</a></li><li><a href="webScience.module_matching.html">matching</a></li><li><a href="webScience.module_messaging.html">messaging</a></li><li><a href="webScience.module_pageClassification.html">pageClassification</a></li><li><a href="webScience.module_pageManager.html">pageManager</a></li><li><a href="webScience.module_pageNavigation.html">pageNavigation</a></li><li><a href="webScience.module_scheduling.html">scheduling</a></li><li><a href="webScience.module_socialMediaActivity.html">socialMediaActivity</a></li><li><a href="webScience.module_socialMediaLinkSharing.html">socialMediaLinkSharing</a></li><li><a href="webScience.module_storage.html">storage</a></li><li><a href="webScience.module_userSurvey.html">userSurvey</a></li></ul><h3>Classes</h3><ul><li><a href="webScience.module_events.Event.html">Event</a></li><li><a href="webScience.module_events.EventSingleton.html">EventSingleton</a></li><li><a href="webScience.module_events.EventWithoutOptions.html">EventWithoutOptions</a></li><li><a href="webScience.module_matching.MatchPatternSet.html">MatchPatternSet</a></li><li><a href="webScience.module_storage.Counter.html">Counter</a></li><li><a href="webScience.module_storage.IndexedStorage.html">IndexedStorage</a></li><li><a href="webScience.module_storage.KeyValueStorage.html">KeyValueStorage</a></li></ul><h3>Interfaces</h3><ul><li><a href="webScience.module_linkExposure-LinkExposureDetails.html">LinkExposureDetails</a></li><li><a href="webScience.module_pageNavigation-PageDataDetails.html">PageDataDetails</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Tue Apr 06 2021 12:42:55 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
